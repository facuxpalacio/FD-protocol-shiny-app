density = "density"))),
# Input: histogram inputs
box(title = "Inputs", status = "primary", solidHeader = TRUE,
sliderInput("bins2", "Number of bins:", min = 5, max = 20, value = 10),
),
# Output: Trait plot
box(title = textOutput("caption"), status = "warning", solidHeader = TRUE,
plotOutput("trait_plot"))
),
tabItem(tabName = "collinearity",
# Input: Select traits to plot
box(title = "Select two or more functional traits", status = "primary", solidHeader = TRUE,
checkboxGroupInput("traits_xy1", label = "", choices = NULL)
),
# Output: scatterplots
fluidRow(
box(title = "Scatterplots", status = "warning", solidHeader = TRUE, width = 12,
plotOutput("scatterplots"))
)
),
tabItem(tabName = "missingdata",
# Input: Select traits with missing data
box(title = "You have the following traits with missing data",
checkboxGroupInput("traits_na", label = "", choices = NULL))
),
tabItem(tabName = "step6",
helpText("Now you can compute functional diversity metrics!",
style = "background-color:lightblue; border-radius:5px"),
checkboxGroupInput("step6", "Estimate functional diversity measure(s) of interest",
choices = c("Identify the level of analysis (alpha, beta, gamma)",
"Did you subset your trait data?",
"Select the appropriate method based on the research question",
"Select the appropriate functional diversity metric",
"Identify the level of functional diversity metric measurement"))
),
tabItem(tabName = "traitspace",
# Input: Select traits to plot
box(title = "Select two or more functional traits",
status = "primary", solidHeader = TRUE,
checkboxGroupInput("traits_xy2", label = "", choices = NULL)
),
# Inputs: dendrogram inputs
box(title = "Dendrogram inputs",
status = "primary", solidHeader = TRUE,
checkboxInput("standardize", "Standardize traits", value = FALSE),
radioButtons("dist.metric",
label = "Dissimilarity metric",
choices = c("Euclidean" = "euclidean",
"Manhattan" = "manhattan",
"Gower" = "gower",
"Mahalanobis" = "mahalanobis"),
selected = "gower"),
radioButtons("cluster.method",
label = "Clustering method",
choices = c("Single" = "single",
"Complete" = "complete",
"Average" = "average",
"Ward" = "ward.D2"),
selected = "average")
),
# Input: PCoA arguments
box(title = "PCoA inputs", status = "primary", solidHeader = TRUE,
radioButtons("corrections",
label = "Correction method for negative eigenvalues",
choices = c("None" = "none",
"Lingoes" = "lingoes",
"Cailliez" = "cailliez")),
sliderInput("max.naxes", "Maximum number of dimensions of the trait space",
min = 2, max = 10, value = 2),
sliderInput("alpha1", "Convex hull transparency",
min = 0, max = 1, value = 0.5)
),
# Output: dendrogram, and PCoA
box(title = "Functional dendrogram", status = "warning", solidHeader = TRUE,
plotOutput("dendrogram")
),
box(title = "PCoA", status = "warning", solidHeader = TRUE,
plotOutput("pcoa")
),
# Input: eigenvalues plot
box(title = "Screeplot inputs", status = "primary", solidHeader = TRUE,
sliderInput("axes.eigenvalues", "Number of axes to plot",
min = 2, max = 20, value = 5)
),
# Output: eigenvalues
fluidRow(
box(title = "Screeplots",
status = "warning", solidHeader = TRUE, width = 12,
column(6,
plotOutput("raw_eigenvalues")),
column(6,
plotOutput("rel_eigenvalues"))
))
),
tabItem(tabName = "alpharich",
# Input: Select traits to plot
box(title = "Select two or more functional traits",
status = "primary", solidHeader = TRUE, width = 4,
checkboxGroupInput("traits_xy3", label = "", choices = NULL)
),
# Input: hypervolumes
box(title = "Hypervolume inputs",
status = "primary", solidHeader = TRUE, width = 8,
numericInput("hv.sites", "Number of sites to plot", value = 1),
sliderInput("hv.axes", "Number of dimensions",
min = 0, max = 10, value = 2),
radioButtons("hv.method", "Method",
choices = c("Gaussian kernel density" = "gaussian",
"Box kernel density" = "box",
"Support vector machines" = "svm"),
selected = "gaussian"),
numericInput("npoints", "Number of sampling points", value = 1000),
checkboxInput("hv.abund", "Use abundance as weights?", value = FALSE),
actionButton("build.hv1", "Build hypervolumes")
),
# Output: hypervolumes
box(title = "Hypervolumes", status = "warning", solidHeader = TRUE,
plotOutput("hv")),
box(title = "Alpha functional richness", status = "warning", solidHeader = TRUE,
plotOutput("alpha.hv.FD"))
),
tabItem(tabName = "betarich",
# Inputs: similarity metric
box(title = "Similarity metric", status = "primary", solidHeader = TRUE,
radioButtons("sim.beta.rich", label = "Similarity metric",
choices = c("Jaccard" = "jaccard",
"Sorensen" = "sorensen"),
selected = "jaccard"),
actionButton("build.hv2", "Compute functional richness")
),
box(title = "Total beta functional diversity", status = "warning", solidHeader = TRUE,
plotOutput("total.beta")
),
box(title = "Turnover", status = "warning", solidHeader = TRUE,
plotOutput("turnover.beta")
),
box(title = "Species richness", status = "warning", solidHeader = TRUE,
plotOutput("richness.beta")
),
),
tabItem(tabName = "alphareg",
),
tabItem(tabName = "betareg",
),
tabItem(tabName = "divergence",
),
tabItem(tabName = "similarity",
),
tabItem(tabName = "spcontrib",
),
tabItem(tabName = "step7",
helpText("Fit, interpret, report and validate your statistical model.",
style = "background-color:lightblue; border-radius:5px"),
checkboxGroupInput("step7", "Interpret and validate the results",
choices = c("Select an appropriate statistical model or test to answer your research question",
"Report effect sizes, model support and uncertainty",
"Provide a graphical output if needed",
"Did you validate your model and how?"))
),
tabItem(tabName = "step8",
helpText("Provide enough data and code detail to allow full reproducibility
of your results.",
style = "background-color:lightblue; border-radius:5px"),
checkboxGroupInput("step8", "Ensure reproducibility",
choices = c("Report the software, version and packages you used",
"Deposit data in a public repository",
"Provide your code (tidy and clean)")),
div(
id = "form",
actionButton("submit", "Save filled checklist", class = "btn-primary"),
shinyjs::hidden(
div(
id = "thankyou_msg",
h3("Thanks for creating your protocol! See the output folder for your filled form")
)
))
)
)
)
)
######################################################################################
server <- function(input, output, session) {
url <- a("Palacio", em("et al."), " (2021). A protocol for conducting trait-based
analyses and maximizing their reproducibility. Journal name. XX: XX-XX.",
href = "https://www.google.com/")
output$tab <- renderUI({
tagList(url)
})
# toDisplay <- eventReactive(input$step1, {
#   choices <- c("Which is your research question?",
#                "Indicate your main hypotheses and predictions")
#   if (all(choices %in% input$step1)){
#     return("")
#   } else if (choices[1] %in% input$step1) {
#     return("Your ecological question...")
#   } else if (choices[2] %in% input$step1) {
#     return("You should clearly state...")
#   } else {}
# })
# output$step1 <- renderText({
#   toDisplay()
# })
community_dataset <- reactive({
req(input$community_dataset) # require data
inFile <- input$community_dataset
df <- read.csv(inFile$datapath, header = input$header1, sep = input$sep1)
return(df)
})
# Update traits based on data
trait_dataset <- reactive({
req(input$trait_dataset) # require data
inFile <- input$trait_dataset
df <- read.csv(inFile$datapath, header = input$header2, sep = input$sep2)
updateSelectInput(session, inputId = "trait", choices = colnames(df),
selected = "")
updateSelectInput(session, inputId = "species", choices = c(" ", colnames(df)),
selected = "")
return(df)
})
# View data tables
output$community_table <- renderDataTable(community_dataset(),
options = list(pageLength = 10)) # antes renderTable
output$trait_table <- renderDataTable(trait_dataset(),
options = list(pageLength = 10)) # antes renderTable
# Tab "Summary": Create a summary of the data
output$summary_community <- renderPrint(summary(community_dataset()))
output$summary_trait <- renderPrint(summary(trait_dataset()))
output$nrow_community <- renderText({
paste0("Number of sampling units = ", nrow(community_dataset()))
})
output$ncol_community <- renderText({
paste0("Number of species = ", ncol(community_dataset()))
})
output$nrow_traits <- renderText({
paste0("Number of species or individuals = ", nrow(trait_dataset()))
})
output$ncol_traits <- renderText({
paste0("Number of traits = ", ncol(trait_dataset()))
})
# Tab "Community data": Heatmap, rarefaction curves and histograms
output$heatmap_community <- renderPlot({
if(input$LogX == TRUE){
pheatmap(log(community_dataset() + 1))
} else {
pheatmap(community_dataset())
}
})
output$plot_heatmap<-renderPlot(function(){
name <- paste0('../output/',input$filename, ".pdf")
if(input$savePlot) {
ggsave(name, output$heatmap_community, type="pdf")
}
})
output$rarefaction_curves <- renderPlot({
raref.curve <- rarecurve(community_dataset())
names(raref.curve) <- paste("site", 1:nrow(community_dataset()),
sep = "")
list.long <- mapply(FUN = function(x, y) {
mydf <- as.data.frame(x)
colnames(mydf) <- "value"
mydf$site <- y
mydf$subsample <- attr(x, "Subsample")
mydf
}, x = raref.curve, y = as.list(names(raref.curve)), SIMPLIFY = FALSE)
xy <- do.call(rbind, list.long)
ggplot(xy, aes(x = subsample, y = value, color = site)) +
theme_bw() +
scale_color_discrete() +
geom_line(size = 0.8) +
xlab("Sample size") + ylab("Species richness")
})
output$richness <- renderPlot({
nspp <- data.frame(richness = rowSums(community_dataset()))
ggplot(data = nspp, aes(x = richness)) +
geom_histogram(color = "black", fill = "white", bins = input$bins1) +
xlab("Species richness") + ylab("Frequency")
})
output$prevalence <- renderPlot({
PA.comm <- 1*(community_dataset()>0)
nsites <- nrow(PA.comm)
abundance <- colSums(PA.comm)
prev <- data.frame(prevalence = abundance/nsites)
ggplot(data = prev, aes(x = prevalence)) +
geom_histogram(color = "black", fill = "white", bins = input$bins1) +
xlab("Prevalence") + ylab("Frequency")
})
# Tab "Trait plot": Plot univariate graphs
output$caption <- renderText({
switch(input$plot.type,
"boxplot" = "Boxplot",
"histogram" = "Histogram",
"density" = "Density plot")
})
output$trait_plot <- renderPlot({
sp <- trait_dataset()[, input$species]
tr <- trait_dataset()[, input$trait]
if(is.null(sp)){
plot.type <- switch(input$plot.type,
"histogram" = geom_histogram(color = "black",
fill = "white", alpha = 0.5),
"density" = geom_density(fill = "blue", alpha = 0.5,
col = "blue"),
"boxplot" = geom_boxplot())
ggplot(trait_dataset(), aes(x = tr)) + plot.type
} else {
plot.type <- switch(input$plot.type,
"histogram" = geom_histogram(alpha = 0.5, bins = input$bins2),
"density" = geom_density(alpha = 0.5),
"boxplot" = geom_boxplot())
if(input$plot.type == "boxplot"){
ggplot(trait_dataset(), aes(x = sp, y = tr)) + plot.type
} else {
ggplot(trait_dataset(), aes(x = tr, group = sp, fill = sp)) + plot.type
}
}
})
# Tab "Collinearity": Plot scatterplots and generate correlation matrix
# Identify only numeric variables
numericColumns <- reactive({
df <- trait_dataset()
colnames(df)[sapply(df, is.numeric)]
})
# Update variable selection
observe({
updateCheckboxGroupInput(session, inputId = "traits_xy1",
choices = numericColumns())
})
# Identify variables with missing values
NAcolumns <- reactive({
df <- trait_dataset()
colnames(df)[colSums(is.na(df)) > 0]
})
# Update variable selection
observe({
updateCheckboxGroupInput(session, inputId = "traits_na",
choices = NAcolumns())
})
# Print scatterplot matrix + correlations
output$scatterplots <- renderPlot({
my_fn <- function(data, mapping, ...){
p <- ggplot(data = trait_dataset(), mapping = mapping) +
geom_point(alpha = 0.5, size = 2) +
geom_smooth(method = loess, fill = "blue", color = "blue", ...)
p
}
ggpairs(trait_dataset()[, input$traits_xy1],
lower = list(continuous = my_fn),
upper = list(continuous = "cor"))
})
### Tab "Trait data space": dendrogram and PCoA
allColumns <- reactive({
df <- trait_dataset()
colnames(df)
})
# Update variable selection
observe({
updateCheckboxGroupInput(session, inputId = "traits_xy2",
choices = allColumns())
})
output$dendrogram <- renderPlot({
traits <- trait_dataset()
rownames(traits) <- traits[, 1]
dist.matrix <- vegdist(traits[, input$traits_xy2],
method = input$dist.metric)
cluster <- hclust(dist.matrix, method = input$cluster.method)
ggdendrogram(cluster, rotate = TRUE, theme_dendro = FALSE)
})
output$pcoa <- renderPlot({
if(input$standardize == TRUE){
traits <- scale(trait_dataset())
} else {
traits <- trait_dataset()
}
rownames(traits) <- traits[, 1]
dist.matrix <- vegdist(traits[, input$traits_xy2],
method = input$dist.metric)
pco <- cmdscale(dist.matrix, k = 2, eig = TRUE, add = TRUE)
pcoa.axes <- as.data.frame(pco$points)
efit <- envfit(ord = pco, env = traits[, input$traits_xy2])
vec.sp.df <- as.data.frame(efit$vectors$arrows*sqrt(efit$vectors$r))
trait.names <- colnames(traits[, input$traits_xy2])
hull <- chull(vec.sp.df[, 1:2])
ggplot() +
xlab("Principal Component 1") + ylab("Principal Component 2") +
geom_hline(yintercept = 0, linetype = "dashed", size = 1,
col = "gray") +
geom_vline(xintercept = 0, linetype = "dashed", size = 1,
col = "gray") +
geom_point(data = pcoa.axes, aes(x = V1, y = V2), size = 4,
col = "olivedrab3") +
geom_segment(data = vec.sp.df, aes(x = 0, xend = Dim1 + 0.01,
y = 0, yend = Dim2 + 0.01),
arrow = arrow(length = unit(0.2, "cm")),
col = "cornflowerblue") +
geom_polygon(data = vec.sp.df[hull, ], aes(x = Dim1, y = Dim2), fill = "firebrick1", alpha = input$alpha1) +
geom_text(data = vec.sp.df, aes(x = Dim1, y = Dim2, label = trait.names),
size = 4, check_overlap = TRUE) + theme_minimal() +
xlim(min(vec.sp.df$Dim1) - 0.1, max(vec.sp.df$Dim1 + 0.1)) +
ylim(min(vec.sp.df$Dim2) - 0.1, max(vec.sp.df$Dim2 + 0.1))
})
# Screeplots
output$raw_eigenvalues <- renderPlot({
if(input$standardize == TRUE){
traits <- scale(trait_dataset())
} else {
traits <- trait_dataset()
}
rownames(traits) <- traits[, 1]
dist.matrix <- vegdist(traits[, input$traits_xy2],
method = input$dist.metric)
pco <- cmdscale(dist.matrix, k = input$max.naxes, eig = TRUE, add = TRUE)
naxes <- input$axes.eigenvalues
df <- data.frame(axis = 1:naxes, eig = pco$eig[1:naxes])
ggplot(data = df, aes(x = axis, y = eig)) +
geom_bar(stat = "identity", fill = "steelblue") +
xlab("Component") + ylab("Raw eigenvalue") +
theme_minimal()
})
output$rel_eigenvalues <- renderPlot({
if(input$standardize == TRUE){
traits <- scale(trait_dataset())
} else {
traits <- trait_dataset()
}
rownames(traits) <- traits[, 1]
dist.matrix <- vegdist(traits[, input$traits_xy2],
method = input$dist.metric)
pco <- cmdscale(dist.matrix, k = input$max.naxes, eig = TRUE, add = TRUE)
naxes <- input$axes.eigenvalues
df <- data.frame(axis = 1:naxes, eig = 100*pco$eig[1:naxes]/sum(pco$eig[1:naxes]))
ggplot(data = df, aes(x = axis, y = eig)) +
geom_bar(stat = "identity", fill = "steelblue") +
xlab("Component") + ylab("Relative eigenvalue (%)") +
theme_minimal()
})
### Tab "Richness": compute FRic
# Update variable selection
observe({
updateCheckboxGroupInput(session, inputId = "traits_xy3",
choices = numericColumns())
})
hypervolumes <- eventReactive(input$build.hv1, {
trait <- as.matrix(trait_dataset()[, input$traits_xy3])
rownames(trait) <- colnames(community_dataset())
comm <- community_dataset()[1:input$hv.sites, ]
kernel.build(comm = comm, trait = trait, axes = input$hv.axes,
method = input$hv.method, abund = input$hv.abund,
samples.per.point = input$npoints)
})
output$hv <- renderPlot(plot(hypervolumes()))
alpha.FD <- eventReactive(input$build.hv1, {
kernelFD <- data.frame(site = 1:input$hv.sites,
FD = kernel.alpha(hypervolumes()))
kernelFD
})
output$alpha.hv.FD <- renderPlot({
df <- alpha.FD()
if(input$hv.sites > 15){
ggplot(data = df, aes(x = FD)) + geom_histogram(bins = 5) +
xlab("Alpha functional diversity") + ylab("Frequency")
}
else {
ggplot(data = df, aes(x = site, y = FD)) +
geom_bar(stat = "identity", fill = "steelblue") +
xlab("Site") + ylab("Alpha functional diversity") + theme_bw()
}
})
# Tab: Beta richness
beta.FD <- eventReactive(input$build.hv2, {
kernel.beta.hv <- kernel.beta(hypervolumes(), func = input$sim.beta.rich)
kernel.beta.hv
})
output$total.beta <- renderPlot({
pheatmap(as.matrix(beta.FD()$Btotal))
})
output$turnover.beta <- renderPlot({
pheatmap(as.matrix(beta.FD()$Brepl))
})
output$richness.beta <- renderPlot({
pheatmap(as.matrix(beta.FD()$Brich))
})
formData <- reactive({
data <- sapply(fieldsAll, function(x) input[[x]])
data <- c(data, date = humanTime())#add escape characters to commas to avoid breaking up into more than 1 cell
data<-gsub(",", "\\,", data)
data <- t(data)
colnames(data)<-c(fieldsAll, "date")
data
})
saveData <- function(data) {
fileName <- sprintf("FDprotocol_%s.csv",
humanTime())
write.csv(x = data, file = file.path(responsesDir, fileName),
row.names = FALSE)
write.csv(output$trait_table, file = file.path(responsesDir,'trait_table', fileName) )
write.csv(output$community_table, file = file.path(responsesDir, 'community_table',fileName) )
}
# action to take when submit button is pressed
observeEvent(input$submit, {
shinyjs::show("thankyou_msg")
saveData(formData())
})
}
fieldsAll <- c("step1","hyp","nohyp", "scale", "unit","pow1", "pow2", "prer1", "prer2", "foc","reso", "ntax", "s_eff", "step4", "step5", "step6", "step7", "step8")
responsesDir <- file.path("../output")
humanTime <- function() format(Sys.time(), "%Y%m%d")
shinyApp(ui = ui, server = server)
?ggsave
runApp()
runApp()
runApp()
runApp()
